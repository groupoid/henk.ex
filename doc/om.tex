% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large Groupoid Infinity}}\\
        \textsc{Kyiv, Ukraine}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}
\vspace{3cm}   {\Large \bf Intermediate Language with Dependent Types and Strong Normalization for Erlang/OTP applications.\\}\par
%\vspace{0.3cm} {\Large Technical Article\par}
\vspace{0.3cm} {\Large Maxim Sokhatsky\par}
\vspace{4cm}   {\Large 2016---2017}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents

\newpage
\section{Introduction}

\vspace{1cm}

\subsection{History}

\paragraph{}
{\bf LISP}. Untyped lambda calculus was discovered as an inner language of the space
at origin (Curry, Church, 1932). This language was manifested as LISP (McCarthy, 1958)
that was built upon: cons, nil, eq, atom, car, cdr, lambda, apply and id.
It was parts of inductive types lately known as inductive type constructors.
Still untyped lambda calculus is used as an extraction target for many
provers (Idris, F*), and also manifests in different domain languages (JavaScript, Erlang).

\paragraph{}
{\bf ML/LCF}. Further teardown of inner space language was ML language, founded merely on algebraic
datatypes and algebra on higher terms rather than categorical semantic. Lately it
was fixed with categorical methods in CPL (Hagino, 1987) and Charity (Cockett, 1992).
Milner, assisted by Morris and Newey designed Meta Language for the purpose of builing LCF
in early 70-s. LCF was a predecessor family of automated math provers: HOL88,
HOL90, HOL98 and HOL/Isabelle which is now built using Poly/ML.

\paragraph{}
{\bf Fully Automated Provers}. In that period during 80-90s other automated math systems were appeared:
AUTOMATH (de Bruijn, 1967), Mizar (Trybulec, 1989), PVS (Owre, Rushby, Shankar, 1995),
ACL2 (Boyer, Kaufmann, Moore, 1996) and Otter (McCune, 1996).

\paragraph{}
{\bf MLTT}. Contemporary provers (built upon consistent Martin-Löf Type Theory, 1972)
like Agda, Coq, Lean, F*, Idris are based on Barendregt
and Coquand' Calculus of Constructions with different flavours of inifinity universe hierarchies
and Calculus of Inductive Constructions for modeling polynomial functors of well-founded trees.
Some of them are automated and some are trying to be and general purpose
programming languages with proving facilities, like Idris, Coq (coq.io), Agda (M-Alonso).

\paragraph{}
{\bf Cubical Type Theory}
The further extensions of MLTT theory is a Homotopy Types needed
for reasoning about abstract shapes and multidimentional path types.
The Cubical approach was chosen in favour of Globular and Simplical
due to computability of Voevodsky's univalence axiom.

\subsection{Background}
From the partical point of view there are exists two approaches.
One involve the usage of two languages: meta language for your models
and separate language for prover, like in {\bf HOL}, {\bf Andromeda} or {\bf NuPRL}, {\bf TLA+}, {\bf Twelf}.
The second approach propose embedding models into a unified language.
And certified programs are extrated as proofs from that models. This is a land of MLTT provers.

\newpage
\section{Motivation and Vision}

\paragraph{}
{\bf From PTS to HTS}. We want to have flexible detachable
layers on top of PTS core. Then Sigma for proving.
Then well-founded trees or polynomial functors as known as data and record.
Then higher path types, interval arithmetic, glue and comp for HIT. The semantic
in each layer remains the same -- category theory.

\paragraph{}
{\bf Extensible Language Design}. Encoding of inductive types is based on categorical
semantic of compilation to PTS. AST of the PTS language is defined
defined in terms of inductive constructions. The language of polynomial
functors (data and record) and core language of the process calculus
(spawn, receive and send) are the syntax extensions of the Om language.

\paragraph{}
{\bf Changable Encodings}. PTS lambda encodings differs in terms of computational properties.
Most known and oldest is Church-Boehm-Berrarducci encoding which has really bad properties,
such as O(n) for pred and extended complexity for recursors.
Another well known are encodings are: Scott (lazyness),
Parigot (lazyness and constant-time iterators), CPS (continuations).
However most of them require variations of Fixpoint types.
Real life efficient encoding without fixpoint with good
computational properties seems doesn't exist. We want our language
be flexible and selective to fixpoint type. Also we want to have switchable encodings.

\paragraph{}
{\bf Proved Categorical Semantic}. There was modeled a math model (using
higher-order categorical logic) of encoding, which calculates (co)limits in a
cathegory of (co)algebras built with given set of (de)constructors.
We call such encoding in honour of Lambek lemma that leeds us to the
equality of (co)initial object and (co)limit in the categories of (co)algebras.
Such encoding works with dependent types and its consistency is proved in Lean model.

\paragraph{}
{\bf General Architecture}. This article covers only the central part of
of the proving system, the {\bf OM} intermediate language with strong
normalization properties and extraction to {\bf Erlang/OTP} bytecode.
Also we describe briefly the prototype of {\bf EXE} language enriched
with inductive constructions and fixpoint in core.

\newpage
\section{Pure Type System as Intermediate Language}

   \paragraph{}
   The Om language is a dependently typed lambda calculus, an extension of Barendregt'
   and Coquand Calculus of Constructions with predicative hierarchy of indexed universes.
   There is no fixpoint axiom needed for the definition of infinity term dependance.

   \paragraph{}
   All terms respect ranking $Axioms$ inside sequence of universes $Sorts$ and complexity of the
   dependent term is equal maximum complexity of term and its dependency $Rules$. The type
   system is completely described by the following PTS notation (due to Barendregt):

$$
\begin{cases}
    Sorts = Type.\{i\},\ i : Nat\\
    Axioms = Type.\{i\} : Type.\{inc\ i\}\\
    Rules = Type.\{i\} \leadsto Type.\{j\} : Type.\{max\ i\ j\}\\
\end{cases}
$$

   \paragraph{}
   An intermediate Om language is based on Henk\cite{henk} languages described first
   by Erik Meijer and Simon Peyton Jones in 1997. Leter on in 2015 Morte impementation
   of Henk design appeared in Haskell, using Boem-Berrarducci encoding of non-recursive lambda terms.
   It is based only on one type constructor $\Pi$, its special case $\lambda$ and theirs eliminators:
   $apply$ and $curry$, infinity number of universes,
   and one computation rule called $\beta$-reduction.
   The design of Om language resemble Henk and Morte both
   design and implementation. This language indended to be small, concise, easy provable
   and able to produce verifiable peace of code that can be distributed over the networks,
   compiled at target with safe trusted linkage.

   \subsection{BNF}
\vspace{0.5cm}
   Om syntax is compatible with $\lambda C$ Coquand's Calculus of Constructions presented
   in Morte and Henk languages. However it has extension in a part of specifying
   universe index as a {\bf Nat} number.

\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
   <> ::= #option
    I ::= #identifier
    U ::= * < #number >
    O ::= U
        | I | ( O ) | O O | O $\rightarrow$ O
        | $\lambda$ ( I : O ) $\rightarrow$ O
        | $\forall$ ( I : O ) $\rightarrow$ O
\end{lstlisting}

Equivalent tree encoding for parsed terms is following:
\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
data pts = star (n: nat)
         | var (n: name)
         | app (f a: pts)
         | lambda (x: name) (d c: pts)
         | pi (x: name) (d c: pts)
\end{lstlisting}

\newpage
\subsection{Universes}

The OM language is a higher-order dependently typed lambda calculus,
an extension of Coquand's Calculus of Constructions
with the predicative/impredicative hierarchy of indexed universes.
This extension is motivated avoiding paradoxes in dependent theory.
Also there is no fixpoint axiom needed for the definition
of infinity term dependance.

\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
    U_0 : U_1 : U_2 : U_3 : ...

    U_0 --- propositions
    U_1 --- values and sets
    U_2 --- types
    U_3 --- sorts
\end{lstlisting}

\begin{equation}
\tag{S}
\dfrac
{o : Nat}
{Type_o}
\end{equation}

\subsection{Predicative Universes}

All terms obey the A ranking inside the sequence of S universes,
and the complexity R of the dependent term is equal to a maximum of
the term's complexity and its dependency.
The universes system is completely described by the following
PTS notation (due to Barendregt):

\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
    $S$    (n : nat) = U n
    $A_1$ (n m : nat) = U n : U m where m > n      - cumulative
    $R_1$ (m n : nat) = U m $\rightarrow$ U n : U (max m n)  - predicative
\end{lstlisting}

Note that predicative universes are incompatible with Church lambda term encoding.
You can switch predicative vs impredicative uninverses by typecheker parameter.

\[
\tag{$A_1$}
\dfrac{i: Nat, j: Nat, i < j}{Type_i : Type_j}
\]

\[
\tag{$R_1$}
\dfrac{i : Nat, j : Nat}{Type_i \rightarrow Type_j : Type_{max(i,j)} }
\]

\subsection{Impredicative Universes}
Propositional contractible bottom space is the only
available extension to predicative hierarchy that not leads to inconsistency.
However there is another option to have infinite
impredicative hierarchy.

\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
    $A_2$   (n : nat) = U n : U (n + 1)   - non-cumulative
    $R_2$ (m n : nat) = U m $\rightarrow$ U n : U n - impredicative
\end{lstlisting}

\begin{equation}
\tag{$A_2$}
\dfrac
{i: Nat}
{Type_i : Type_{i+1}}
\end{equation}

\begin{equation}
\tag{$R_2$}
\dfrac
{i : Nat,\ \ \ \ j : Nat}
{Type_i \rightarrow Type_{j} : Type_{j}}
\end{equation}

\subsection{Single Axiom Language}

This langauge is called one axiom language (or pure) as eliminator
and introduction adjoint functors inferred from type formation rule.
The only computation rule of Pi type is called beta-reduction.

\begin{equation}
\tag{$\Pi$-formation}
\dfrac
{x:A \vdash B : Type}
{\Pi\ (x:A) \rightarrow B : Type}
\end{equation}

\begin{equation}
\tag{$\lambda$-intro}
\dfrac
{x:A \vdash b : B}
{\lambda\ (x:A) \rightarrow b : \Pi\ (x: A) \rightarrow B }
\end{equation}

\begin{equation}
\tag{$App$-elimination}
\dfrac
{f: (\Pi\ (x:A) \rightarrow B)\ \ \ a: A}
{f\ a : B\ [a/x]}
\end{equation}

\begin{equation}
\tag{$\beta$-computation}
\dfrac
{x:A \vdash b: B\ \ \ a:A}
{(\lambda\ (x:A) \rightarrow b)\ a = b\ [a/x] : B\ [a/x]}
\end{equation}

\vspace{0.5cm}
This language could be embedded in itself and used
as Logical Framework for the Pi type:

\begin{lstlisting}[mathescape=true]
record Pi (A: Type) :=
       (intro:  (A $\rightarrow$ Type) $\rightarrow$ Type)
       (lambda: (B: A $\rightarrow$ Type) $\rightarrow$ pi A B $\rightarrow$ intro B)
       (app:    (B: A $\rightarrow$ Type) $\rightarrow$ intro B $\rightarrow$ pi A B)
       (applam: (B: A $\rightarrow$ Type) (f: pi A B) $\rightarrow$ (a: A) $\rightarrow$
                Path (B a) ((app B (lambda B f)) a) (f a))
       (lamapp: (B: A $\rightarrow$ Type) (p: intro B) $\rightarrow$
                Path (intro B) (lambda B ($\lambda$ (a:A) $\rightarrow$ app B p a)) p)

\end{lstlisting}

We extend the $PTS\infty$ with remote AST node wich means remote file loading
from trusted storage, anyway this will be checked by typechecker. We deny recursion
over remote node. We also add index to var for simplified de Bruin indexes.

\begin{lstlisting}[mathescape=true]
data om = star             (n: nat)
        | var    (n: name) (n: nat)
        | remote (n: name) (n: nat)
        | app                       (f a: pts)
        | lambda (x: name)          (d c: pts)
        | arrow                     (d c: pts)
        | pi     (x: name)          (d c: pts)
\end{lstlisting}

\newpage

\subsection{Hierarchy}
H returns the target Universe of B term dependendance on A. Thereare two dependance rules known
as predicative and impredicative which returns max universe or universe of last term respectively.

\begin{lstlisting}[mathescape=true]
dep A B impredicative $\rightarrow$ B
dep A B predicative   $\rightarrow$ max A B

h Arg Out $\rightarrow$ dep Arg Out om:hierarchy(impredicative)
\end{lstlisting}

\subsection{Universes}
Star returns the number of Universe. If argument is not Universe it returns $\{error,\_\}$.

\begin{lstlisting}[mathescape=true]
star (:star,N) $\rightarrow$ N
star _         $\rightarrow$ (:error, "*")
\end{lstlisting}

\subsection{Functions}
Func returns true if the argument is functional space. Otherwise returns $\{error,\_\}$.

\begin{lstlisting}[mathescape=true]
func ((:forall,),(I,O)) $\rightarrow$ true
func T                  $\rightarrow$ (:error,(:forall,T))
\end{lstlisting}

\subsection{Variables}
Var returns true if the var $N$ is defined in dictionary $B$. Otherwise returns $\{error,\_\}$.

\begin{lstlisting}[mathescape=true]
var N B                $\rightarrow$ var N B (proplists:is_defined N B)
var N B true           $\rightarrow$ true
var N B false          $\rightarrow$ (:error,("free var",N,proplists:get_keys(B)))
\end{lstlisting}

\subsection{Shift}
Shift renames var N in N

\begin{lstlisting}[mathescape=true]
sh (:var,(N,I)),N,P) when I>=P  $\rightarrow$ (var,(N,I+1))
sh ((:forall,(N,0)),(I,O)),N,P) $\rightarrow$ ((:forall,(N,0)),sh I N P,sh O N P+1)
sh ((:lambda,(N,0)),(I,O)),N,P) $\rightarrow$ ((:lambda,(N,0)),sh I N P,sh O N P+1)
sh (Q,(L,R),N,P)                $\rightarrow$ (Q,sh L N P,sh R N P)
sh (T,N,P)                      $\rightarrow$ T
\end{lstlisting}

\subsection{Substitution}

\begin{lstlisting}[mathescape=true]
sub Term Name Value               $\rightarrow$ sub Term Name Value 0
sub (:arrow,         (I,O)) N V L $\rightarrow$ (:arrow,         sub I N V L,sub O N V L);
sub ((:forall,(N,0)),(I,O)) N V L $\rightarrow$ ((:forall,(N,0)),sub I N V L,sub O N(sh V N 0)L+1)
sub ((:forall,(F,X)),(I,O)) N V L $\rightarrow$ ((:forall,(F,X)),sub I N V L,sub O N(sh V F 0)L)
sub ((:lambda,(N,0)),(I,O)) N V L $\rightarrow$ ((:lambda,(N,0)),sub I N V L,sub O N(sh V N 0)L+1)
sub ((:lambda,(F,X)),(I,O)) N V L $\rightarrow$ ((:lambda,(F,X)),sub I N V L,sub O N(sh V F 0)L)
sub (:app,           (F,A)) N V L $\rightarrow$ (:app,sub F N V L,sub A N V L)
sub (:var,           (N,L)) N V L $\rightarrow$ V
sub (:var,           (N,I)) N V L when I>L $\rightarrow$ (:var,(N,I-1))
sub T                       _ _ _ $\rightarrow$ T.
\end{lstlisting}


\subsection{Type Checker}

For sure in pure system we should be careful with {\bf :remote} AST node. Remote
AST nodes like {\bf \#List/Cons or \#List/map} are a remote link to files. So using
trick one should desire circular dependency over {\bf :remote}. This is denied in
the system. Same notes apply to normalization and definitional equality.

\begin{lstlisting}[mathescape=true]
type (:star,N)               _ $\rightarrow$ (:star,N+1)
type (:var,(N,I))            D $\rightarrow$ let true = var N D in keyget N D I
type (:remote,N)             D $\rightarrow$ cache type N D
type (:arrow,(I,O))          D $\rightarrow$ (:star,h(star(type I D)),star(type O D))
type ((:forall,(N,0)),(I,O)) D $\rightarrow$ (:star,h(star(type I D)),star(type O [(N,norm I)|D]))
type ((:lambda,(N,0)),(I,O)) D $\rightarrow$ let star (type I D),
                                  NI = norm I in ((:forall,(N,0)),(NI,type(O,[(N,NI)|D])))
type (:app,(F,A))            D $\rightarrow$ let T = type(F,D),
                                  true = func T,
                                  ((:forall,(N,0)),(I,O)) = T,
                                  Q = type A D,
                                  true = eq I Q in norm (subst O N A)
\end{lstlisting}

\subsection{Normalization}

Normalization perform substitutions on applications to functions searching
over all function spaces, performing recursive normalization over the lambda and pi nodes.

\begin{lstlisting}[mathescape=true]
norm :none                   $\rightarrow$ :none
norm :any                    $\rightarrow$ :any
norm (:app,(F,A))            $\rightarrow$ case norm F of
                                ((:lambda,(N,0)),(I,O)) $\rightarrow$ norm (subst O N A)
                                                     NF $\rightarrow$ (:app,(NF,norm A)) end
norm (:remote,N)             $\rightarrow$ cache (norm N [])
norm (:arrow,         (I,O)) $\rightarrow$ ((:forall,("_",0)),(norm I,norm O))
norm ((:forall,(N,0)),(I,O)) $\rightarrow$ ((:forall,(N,0)),    (norm I,norm O))
norm ((:lambda,(N,0)),(I,O)) $\rightarrow$ ((:lambda,(N,0)),    (norm I,norm O))
norm T                       $\rightarrow$ T
\end{lstlisting}

\subsection{Definitional Equality}

Definitional Equality simple ensures the erlang term equality.

\begin{lstlisting}[mathescape=true]
eq ((:forall,("_",0)), X) (:arrow,Y)     $\rightarrow$ eq X Y
eq (:app,(F1,A1))         (:app,(F2,A2)) $\rightarrow$ let true = eq F1 F2 in eq A1 A2
eq (:star,N)              (:star,N)      $\rightarrow$ true
eq (:var,(N,I))           (:var,(N,I))   $\rightarrow$ true
eq (:remote,N)            (:remote,N)    $\rightarrow$ true
eq ((:farall,(N1,0)),(I1,O1))
   ((:forall,(N2,0)),(I2,O2)) $\rightarrow$
   let true = eq I1 I2 in eq O1 (subst (shift O2 N1 0) N2 (:var,(N1,0)) 0)
eq ((:lambda,(N1,0)),(I1,O1))
   ((:lambda,(N2,0)),(I2,O2)) $\rightarrow$
   let true = eq I1 I2 in eq O1 (subst (shift O2 N1 0) N2 (:var,(N1,0)) 0)
eq (A,B)                      $\rightarrow$ (:error,(:eq,A,B))
\end{lstlisting}

\newpage
\section{Language Usage}

In this section we will lift PTS system to MLTT system by defining
$Sigma$ and $Equ$ types to pure $Pi$ type. We will use Boehm inductive
dependent encoding.

\subsection{Sigma Type}

\paragraph{}
Here we will show you some examples of Om Language usage.
The PTS system is extremely powerful even without Sigma type. But
we can encode {\bf Sigma} type similar how we encode {\bf Prod}
tuple pair in Boehm encoding. Let's formulate Sigma type as inductive type:

\begin{lstlisting}[mathescape=true]
data Sigma (A: Type) (P: A -> Type): Type =
     (intro: (x:A) (y:P x) -> Sigma A P)
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
-- Sigma/@
   \ (A: *)
-> \ (P: A -> *)
-> \/ (Exists: *)
-> \/ (Intro: \/ (x: A) -> \/ (y: P x) -> Exists)
-> Exists

-- Sigma/Intro
   \ (A: *)
-> \ (P: A -> *)
-> \ (x: A)
-> \ (y: P x)
-> \ (Exists: *)
-> \ (Intro: \/ (z: A) -> P z -> Exists)
-> Intro x y

-- Sigma/fst
   \ (A: *)
-> \ (B: A -> *)
-> \ (S: #Sigma/@ A B)
-> S A ( \(x: A) -> \(_: B x) -> x)

-- Sigma/snd
   \ (A: *)
-> \ (B: A -> *)
-> \ (S: #Sigma/@ A B)
-> S (B (#Sigma/fst A B S))
     (\(_: A) -> \(y: B (#Sigma/fst A B S)) -> y)

-- Sigma/test
#Sigma/Intro #Nat/@ #List/@ #Nat/Zero (#List/Nil #Nat/@)
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
> om:fst(om:erase(om:norm(om:a("#Sigma/snd #Nat/@ #List/@ #Sigma/test")))).
{{$\lambda$,{'Cons',0}},
 {any,{{$\lambda$,{'Nil',0}},{any,{var,{'Nil',0}}}}}}
\end{lstlisting}

For using {\bf Sigma} type for Logic purposes one should change the
home Universe of the type to {\bf Prop}. Here it is:

\begin{lstlisting}[mathescape=true]
data Sigma (A: Prop) (P: A -> Prop): Prop =
     (intro: (x:A) (y:P x) -> Sigma A P)
\end{lstlisting}

\newpage
\subsection{Equality Type}

Another example of expressivness is Equality type a la Martin-Löf.

\begin{lstlisting}[mathescape=true]
data Equ (A: Type): A -> A -> Type :=
     (refl (a: A): Equ A a a)
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
-- Equ/@
   \ (A: *)
-> \ (x: A)
-> \ (y: A)
-> \/ (Equ: A -> A -> *)
-> \/ (Refl: \/ (z: A) -> Equ z z)
-> Equ x y

-- Equ/Refl
   \ (A: *)
-> \ (x: A)
-> \ (Equ: A -> A -> *)
-> \ (Refl: \/ (z: A) -> Equ z z)
-> Refl x
\end{lstlisting}

You cannot construct lambda that will check different values of A type,
however you may want to use built-in definitionaly equality and
normalization feature of typecheker to actually compare two values:

\begin{lstlisting}[mathescape=true]
> om:print(
  om:type(
  om:a("(\\ (z: #Equ/@ #Nat/@ #Nat/One #Nat/One) -> #Prop/True)"++
       " (#Equ/Refl #Nat/@ (#Nat/Succ #Nat/Zero))"))).
   \/ (True: *0)
-> \/ (Intro: True)
-> True
ok

> om:print(
  om:type(
  om:a("(\\ (z: #Equ/@ #Nat/@ #Nat/One #Nat/One) -> #Prop/True)"++
       " (#Equ/Refl #Nat/@ #Nat/Zero)"))).
** exception error: no match of right hand side value
   {error,{"==",
          {app,{{var,{'Succ',0}},{var,{'Zero',0}}}},
          {var,{'Zero',0}}}}
\end{lstlisting}

\newpage
\subsection{Effect Type System}

\paragraph{}
This work expects to compile to limited target platforms. For now Erlang, Haskell and LLVM are awaiting.
Erlang version is expected to be useful both on LING and BEAM Erlang virtual machines. This language
allows you to define trusted operations in System F and extract this routines to Erlang/OTP platform
and plug as trusted resourses. As example we also provide infinite coinductive process creation
and inductive shell that linked to Erlang/OTP IO functions directly.

\paragraph{IO protocol}
We can construct in pure type system the state machine based on (co)-free
monads driven by IO protocols. Assume String is equal List of Nat (as it is in Erlang natively),
and three external constructors: getLine, putLine and pure. We need to
put correspondent implementations on host platform as parameters to perform the actual IO.

\begin{lstlisting}[mathescape=true]
String: Type = List Nat
data IO: Type =
     (getLine: (String -> IO) -> IO)
     (putLine: String -> IO)
     (pure: () -> IO)
\end{lstlisting}

\subsection{Corecursive Example}

Infinity I/O Type Spec.

\begin{lstlisting}[mathescape=true]
-- IOI/@
   \ (r : *)
-> \/ (x : *)
-> (\/ (s : *) -> s -> (s -> #IOI/F r s) -> x)
-> x

-- IOI/F
   \ (a : *)
-> \ (State : *)
-> \/ (IOF : *)
-> \/ (PutLine_ : #IOI/data -> State -> IOF)
-> \/ (GetLine_ : (#IOI/data -> State) -> IOF)
-> \/ (Pure_ : a -> IOF)
-> IOF

-- IOI/MkIO
   \ (r : *)
-> \ (s : *)
-> \ (seed : s)
-> \ (step : s -> #IOI/F r s)
-> \ (x : *)
-> \ (k : forall (s : *) -> s -> (s -> #IOI/F r s) -> x)
-> k s seed step

-- IOI/data
#List/@ #Nat/@
\end{lstlisting}

\newpage
Infinite I/O Sample Program.

\begin{lstlisting}[mathescape=true]
( \ (r: *1)
 -> ( (((#IOI/MkIO r) (#Maybe/@ #IOI/data)) (#Maybe/Nothing #IOI/data))
    ( \ (m: (#Maybe/@ #IOI/data))
     -> (((((#Maybe/maybe #IOI/data) m) ((#IOI/F r) (#Maybe/@ #IOI/data)))
           ( \ (str: #IOI/data)
            -> ((((#IOI/putLine r) (#Maybe/@ #IOI/data)) str)
                (#Maybe/Nothing #IOI/data))))
         (((#IOI/getLine r) (#Maybe/@ #IOI/data))
          (#Maybe/Just #IOI/data))))))
\end{lstlisting}

Erlang Coinductive Bindings.

\begin{lstlisting}[mathescape=true]
copure() ->
    fun (_) -> fun(IO) -> IO end end.

cogetLine() ->
    fun(IO) -> fun(_) ->
        L = ch:list(io:get_line("> ")),
        ch:ap(IO,[L]) end end.

coputLine() ->
    fun (S) -> fun(IO) ->
        X = ch:unlist(S),
        io:format(": "), io:put_chars(X),
        case X of "0\n" -> list([]);
                      _ -> corec() end end end.

corec() ->
    ap('Morte':corecursive(),
        [copure(),cogetLine(),coputLine(),copure(),list([])]).
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
> om_extract:extract("priv/normal/IOI").
ok
> Active: module loaded: {reloaded,'IOI'}
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
> om:corec().
> 1
: 1
> 0
: 0
#Fun<List.3.113171260>
\end{lstlisting}

\newpage

\subsection{Recursive Example}

I/O Type Spec.

\begin{lstlisting}[mathescape=true]
-- IO/@
   \ (a : *)
-> \/ (IO : *)
-> \/ (GetLine_ : (#IO/data -> IO) -> IO)
-> \/ (PutLine_ : #IO/data -> IO -> IO)
-> \/ (Pure_ : a -> IO)
-> IO

-- IO/replicateM
   \ (n: #Nat/@)
-> \ (io: #IO/@ #Unit/@)
-> #Nat/fold n (#IO/@ #Unit/@)
               (#IO/[>>] io)
               (#IO/pure #Unit/@ #Unit/Make)
\end{lstlisting}

Guarded Recursion I/O Sample Program.

\begin{lstlisting}[mathescape=true]
((#IO/replicateM #Nat/Five)
 ((((#IO/[>>=] #IO/data) #Unit/@) #IO/getLine) #IO/putLine))
\end{lstlisting}

Erlang Inductive Bindings.

\begin{lstlisting}[mathescape=true]
pure() ->
    fun(IO) -> IO end.

getLine() ->
    fun(IO) -> fun(_) ->
        L = ch:list(io:get_line("> ")),
        ch:ap(IO,[L]) end end.

putLine() ->
    fun (S) -> fun(IO) ->
        io:format(": "),
        io:put_chars(ch:unlist(S)),
        ch:ap(IO,[S]) end end.

rec() ->
    ap('Morte':recursive(),
        [getLine(),putLine(),pure(),list([])]).
\end{lstlisting}


Here is example of Erlang/OTP shell running recursive example.

\begin{lstlisting}[mathescape=true]
> om:rec().
> 1
: 1
> 2
: 2
> 3
: 3
> 4
: 4
> 5
: 5
#Fun<List.28.113171260>
\end{lstlisting}




\newpage
\section{Language with Inductive Types}

Despite we can encode inductive types in PTS, the best usage of inductive types
comes with recursors and fixpoint type that allow recursive typecheck, limiting
from the other side the normalization proerties.

\paragraph{}
So called Calculus of Inductive constructions are used as a top language on top of
PTS to reason about inductive types. Here we will show you a sketch of such
inductive language model which indendent to be a language extension to PTS system.

\paragraph{}
Exe is a general purpose functional language with $\Pi$ and $\Sigma$ types,
recursive algebraic types, higher order functions,
corecursion, free monad for effects encoding. It compiles
to a small MLTT core of dependent type system with inductive types and equality.

\paragraph{}
It also has an $Id$ type (with its recursor) wich is useful for proving things,
$Let$ sytax sugar, case analisys over inductive types and also a $pi$-Calculus primitives:
$spawn$, $send$ and $receive$ which are native mappings to Erlang/OTP.

\subsection{BNF}


\begin{lstlisting}[mathescape=true]
    <> ::= #option
    [] ::= #list
     | ::= #sum
     1 ::= #unit
     I ::= #identifier

     U ::= Type < #nat >
     T ::= 1 | ( I : O ) T
     F ::= 1 | I : O = O , F
     B ::= 1 | [ | I [ I ] $\rightarrow$ O ]
     L ::= 1 | I T
     O ::= I | ( O ) |
           U | O $\rightarrow$ O
             | O O
             | fun ( I : O ) $\rightarrow$ O
             | fst O
             | snd O
             | id O O O
             | transport O O O O O
             | ( I : O ) * O
             | ( I : O ) $\rightarrow$ O
             | data   I T : O := T
             | record I T : O := T
             | let F in O
             | case O B
             | receive B
             | spawn O O
             | send O O
\end{lstlisting}

That is how we see the language informally.

\newpage

However in real life we use grammar parser generators.
The Erlang version of parser encoded with OTP library {\bf yecc} which implements
LALR-1 grammar generator. This version resembles the model and slightly based on cubical
type checker by Mortberg et all.

\begin{lstlisting}
mod   -> 'module' id 'where' imp dec       : {module,'$2','$3','$4','$5'}.
imp   -> skip imp                          : '$2'.
imp   -> '$empty'                          : [].
imp   -> 'import' id imp                   : [{import,'$2'}|'$3'].
tele  -> '$empty'                          : [].
tele  -> '(' exp ':' exp ')' tele          : {tele,uncons('$2'),'$4','$6'}.
exp   -> app                               : '$1'.
exp   -> exp arrow exp                     : {arrow,'$1','$3'}.
exp   -> '(' exp ')'                       : '$2'.
exp   -> lam '(' exp ':' exp ')' arrow exp : {lam,uncons('$3'),'$5','$8'}.
exp   -> '(' exp ':' exp ')' arrow exp     : {pi,uncons('$2'),'$4','$7'}.
exp   -> '(' id ':' exp ')' '*' exp        : {sigma,'$2','$4','$7'}.
exp   -> id                                : '$1'.
app   -> exp exp                           : {app,'$1','$2'}.
dec   -> '$empty'                          : [].
dec   -> def skip dec                      : ['$1'|'$3'].
def   -> 'data' id tele '=' sum            : {data,'$2','$3','$5'}.
def   -> id tele ':' exp '=' exp           : {def,'$1','$2','$4','$6'}.
sum   -> '$empty'                          : [].
sum   -> id tele                           : {ctor,'$1','$2'}.
sum   -> id tele '|' sum                   : [{ctor,'$1','$2'}|'$4'].
\end{lstlisting}

\subsection{AST}

The model in Cubical and Coq of the Exe language is available at
infinity\footnote{https://github.com/groupoid/infinity/tree/master/priv}
repository of groupoid organization.

\begin{lstlisting}[mathescape=true]
 data tele (A: U)   = emp | tel (n: name) (b: A) (t: tele A)
 data branch (A: U) =        br (n: name) (args: list name) (term: A)
 data label (A: U)  =       lab (n: name) (t: tele A)
 data ind
    = star                        (n: nat)
    | var    (n: name)            (i: nat)
    | app              (f a: ind)
    | lambda (x: name) (d c: ind)
    | pi     (x: name) (d c: ind)
    | sigma  (n: name) (a b: ind)
    | arrow            (d c: ind)
    | pair             (a b: ind)
    | fst              (p:   ind)
    | snd              (p:   ind)
    | id               (a b: ind)
    | idpair           (a b: ind)
    | idelim           (a b c d e: ind)
    | data_  (n: name) (t: tele ind) (labels:   list (label ind))
    | case   (n: name) (t: ind)      (branches: list (branch ind))
    | ctor   (n: name)               (args:     list ind)
\end{lstlisting}



\newpage
\subsection{Inductive Types}

\paragraph{}
There are two types of recursion: one is least fixed point (as $F_A\ X = 1 + A\times X$
or $F_A\ X = A + X\times X$), in other words the recursion with a base (terminated with a bounded value),
lists and trees are examples of such recursive structures (so we call induction recursive sums);
and the second is greatest fixed point or recursion withour a base (as $F_A\ X = A\times X $) ---
such kind of recursion on infinite lists (codata, streams, coinductive types) we can call recursive products.\\

\subsection{Polynomial Functors}
Least fixed point trees are called well-founded trees and encode polynomial functors.\\

\noindent Natural Numbers: $\mu\ X \rightarrow 1 + X$\\
List A: $\mu\ X \rightarrow 1 + A \times X$\\
Lambda calculus: $\mu\ X \rightarrow 1 + X \times X + X$\\
Stream: $\nu\ X \rightarrow A \times X$\\
Potentialy Infinite List A: $\nu\ X \rightarrow 1 + A \times X$\\
Finite Tree: $\mu\ X \rightarrow \mu\ Y \rightarrow 1 + X \times Y = \mu\ X = List\ X$\\

\paragraph{}
As we know there are several ways to appear for variable in recursive algebraic type.
Least fixpoint are known as an recursive expressions that have a base of recursion
Both recursive and corecursive datatypes could be encoded using Boem-Berarducci encoding
as an non-recursive definitions of folds that include in indentity signature all the
constructor components of (co)inductive type.

\subsection{Lists}
The data type of lists over a given set A can be represented as the initial algebra
$(\mu L_A, in)$ of the functor $L_A(X) = 1 + (A \times X)$. Denote $\mu L_A = List(A)$.
The constructor functions $nil: 1 \rightarrow List(A)$ and
$cons: A \times List(A) \rightarrow List(A)$ are defined by
$nil = in \circ inl$ and $cons = in \circ inr$, so $in = [nil,cons]$.
Given any two functions $c: 1 \rightarrow C$ and $h: A \times C \rightarrow C$,
the catamorphism $f = \llparenthesis [c,h] \rrparenthesis : List(A) \rightarrow C$
is the unique solution of the equation system:
\vspace{0.3cm}
$$
\begin{cases}
  f \circ nil  = c \\
  f \circ cons = h \circ (id \times f)
\end{cases}
$$

\paragraph{}
where $f = foldr(c,h)$. Having this the initial algebra is presented with functor
$\mu (1 + A \times X)$ and morphisms sum $[1 \rightarrow List(A), A \times List(A) \rightarrow List(A)]$
as catamorphism. Using this encdoding the base library of List will have following form:

\vspace{0.5cm}
$$
\begin{cases}
foldr = \llparenthesis [ f \circ nil , h] \rrparenthesis, f \circ cons = h \circ (id \times f)\\
len = \llparenthesis [ zero, \lambda\ a\ n \rightarrow succ\ n ] \rrparenthesis \\
(++) = \lambda\ xs\ ys \rightarrow \llparenthesis [ \lambda (x) \rightarrow ys, cons ] \rrparenthesis (xs) \\
map = \lambda\ f \rightarrow \llparenthesis [ nil, cons \circ (f \times id)] \rrparenthesis
\end{cases}
$$

\begin{lstlisting}[mathescape=true]
             data list: (A: *) $\rightarrow$ * :=
                  (nil: list A)
                  (cons: A $\rightarrow$ list A $\rightarrow$ list A)
\end{lstlisting}

$$
\begin{cases}
list = \lambda\ ctor \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow ctor\\
cons = \lambda\ x\ \rightarrow \lambda\ xs \rightarrow \lambda\ list \rightarrow \lambda\ cons \rightarrow\ \lambda\ nil \rightarrow cons\ x\ (xs\ list\ cons\ nil)\\
nil = \lambda\ list \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow nil\\
\end{cases}
$$

\begin{lstlisting}[mathescape=true]
-- List/@
   \ (A : *)
-> \/ (List: *)
-> \/ (Cons: \/ (Head: A) -> \/ (Tail: List) -> List)
-> \/ (Nil: List)
-> List

-- List/Cons
   \ (A: *)
-> \ (Head: A)
-> \ (Tail:
      \/ (List: *)
   -> \/ (Cons:
         \/ (Head: A)
      -> \/ (Tail: List)
      -> List)
   -> \/ (Nil: List)
   -> List)
-> \ (List: *)
-> \ (Cons:
      \/ (Head: A)
   -> \/ (Tail: List)
   -> List)
-> \ (Nil: List)
-> Cons Head (Tail List Cons Nil)

-- List/Nil
   \ (A: *)
-> \ (List: *)
-> \ (Cons:
      \/ (Head: A)
   -> \/ (Tail: List)
   -> List)
-> \ (Nil: List)
-> Nil
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
           record lists: (A B: *) :=
                  (len: list A $\rightarrow$ integer)
                  ((++): list A $\rightarrow$ list A $\rightarrow$ list A)
                  (map: (A $\rightarrow$ B) $\rightarrow$ (list A $\rightarrow$ list B))
                  (filter: (A $\rightarrow$ bool) $\rightarrow$ (list A $\rightarrow$ list A))
\end{lstlisting}
$$
\begin{cases}
len = foldr\ (\lambda\ x\ n \rightarrow succ\ n)\ 0\\
(++) = \lambda\ ys \rightarrow foldr\ cons\ ys\\
map = \lambda\ f \rightarrow foldr\ (\lambda x\ xs \rightarrow cons\ (f\ x)\ xs)\ nil\\
filter = \lambda\ p \rightarrow foldr\ (\lambda x\ xs \rightarrow if\ p\ x\ then\ cons\ x\ xs\ else\ xs)\ nil\\
foldl = \lambda\ f\ v\ xs = foldr\ (\lambda\ xg\rightarrow\ (\lambda \rightarrow g\ (f\ a\ x)))\ id\ xs\ v\\
\end{cases}
$$

\vspace{1cm}
\subsection{Normal Forms}

Here is example of List/map generic function.

\subsubsection*{Lists/map}
{\fontfamily{pcr}\selectfont
\vspace{0.5cm}
$\lambda$ (a: *) $\rightarrow$ $\lambda$ (b: *) $\rightarrow$ $\lambda$ (f: a $\rightarrow$ b) $\rightarrow$ $\lambda$ (xs: $\forall$ (List: *)
$\rightarrow$ $\forall$ (Cons: $\forall$ (head: a) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List) $\rightarrow$ $\forall$ (Nil: List) $\rightarrow$ List)
$\rightarrow$ xs ($\forall$ (List: *) $\rightarrow$ $\forall$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List)
$\rightarrow$ $\forall$ (Nil: List) $\rightarrow$ List) ($\lambda$ (head: a) $\rightarrow$ $\lambda$ (tail: $\forall$ (List: *) $\rightarrow$
$\forall$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List) $\rightarrow$ $\forall$ (Nil: List)
$\rightarrow$ List) $\rightarrow$ $\lambda$ (List: *) $\rightarrow$ $\lambda$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$
(tail: List) $\rightarrow$ List) $\rightarrow$ $\lambda$ (Nil: List) $\rightarrow$ Cons (f head) (tail List Cons Nil))
($\lambda$ (List: *) $\rightarrow$ $\lambda$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$
List) $\rightarrow$ $\lambda$ (Nil: List) $\rightarrow$ Nil)
}

\newpage
\subsection{Prelude Base Library}

The base library is modeled in cubical type checker.

\begin{lstlisting}[mathescape=true]

             data Nat: Type :=
                  (Zero: Unit $\rightarrow$ Nat)
                  (Succ: Nat $\rightarrow$ Nat)

             data List (A: Type) : Type :=
                  (Nil: Unit $\rightarrow$ List A)
                  (Cons: A $\rightarrow$ List A $\rightarrow$ List A)

           record list: Type :=
                  (len: List A $\rightarrow$ integer)
                  ((++): List A $\rightarrow$ List A $\rightarrow$ List A)
                  (map: (A,B: Type) (A $\rightarrow$ B) $\rightarrow$ (List A $\rightarrow$ List B))
                  (filter: (A $\rightarrow$ bool) $\rightarrow$ (List A $\rightarrow$ List A))

           record String: List Nat := List.Nil

             data IO: Type :=
                  (getLine: (String $\rightarrow$ IO) $\rightarrow$ IO)
                  (putLint: String $\rightarrow$ IO)
                  (pure: () $\rightarrow$ IO)

           record IO: Type :=
                  (data: String)
                  ([>>=]: ...)

           record Morte: Type :=
                  (recursive: IO.replicateM Nat.Five
                              (IO.[>>=] IO.data Unit IO.getLine IO.putLine))

\end{lstlisting}

\subsection{Compiler Passes}

The underlying OM typechecker and compiler is a target language for EXE general purpose language.
The overal size of OM language with extractor to Erlang is 263 lines of code.

\begin{center}
\begin{tabular}{lll}
   TOKEN   & 54 LOC & Handcoded Tokenizer\\
   PARSER  & 81 LOC & Parser\\
   NORMAL  & 60 LOC & Term normalization and typechecking\\
   ERASE   & 36 LOC & Delete information about types\\
   EXTRACT & 32 LOC & Extract Erlang Code\\
\end{tabular}
\end{center}

We benchmarked the unrolling of inductive list type in Church
encoding extracted with OM with native erlang {\bf lists:foldl}.

\begin{lstlisting}[mathescape=true]
Pack/Unpack 1 000 000 Inductive Nat:   776407 us
Pack/Unpack 1 000 000 ErlangOTP List:  148084 us
Pack/Unpack 1 000 000 Inductive List: 1036461 us
\end{lstlisting}

\newpage
\begin{thebibliography}{9}

\subsection*{Category Theory}
\bibitem{maclane}    S.MacLane \textit{Categories for the Working Mathematician} 1972
\bibitem{lawvere}    W.Lawvere \textit{Conceptual Mathematics} 1997
\bibitem{curien}     P.Curien \textit{Category theory: a programming language-oriented introduction} 2008

\subsection*{Pure Type Systems}
\bibitem{martinlof}  P.Martin-Löf \textit{Intuitionistic Type Theory} 1984
\bibitem{coquand}    T.Coquand \textit{The Calculus of Constructions.} 1988
\bibitem{henk}       E.Meijer \textit{Henk: a typed intermediate language} 1997
\bibitem{barendregt} H.Barendregt \textit{Lambda Calculus With Types} 2010

\subsection*{Inductive Type Systems}
\bibitem{pfenning}   F.Pfenning \textit{Inductively defined types in the Calculus of Constructions} 1989
\bibitem{wadler}     P.Wadler \textit{Recursive types for free} 1990
\bibitem{gambino}    N.Gambino \textit{Wellfounded Trees and Dependent Polynomial Functors} 1995
\bibitem{dybjer}     P.Dybjer \textit{Inductive Famalies} 1997
\bibitem{jacobs}     B.Jacobs \textit{(Co)Algebras) and (Co)Induction} 1997
\bibitem{vene}       V.Vene \textit{Categorical programming with (co)inductive types} 2000
\bibitem{guevers}    H.Geuvers \textit{Dependent (Co)Inductive Types are Fibrational Dialgebras} 2015

% \subsection*{Pi Calculus}
% \bibitem{comm}       Robin Milner. \textit{A Calculus of Communicating Systems.} 1986.
% \bibitem{commpi}     Robin Milner. \textit{Communicating and Mobile Systems: The $\pi$-calculus.} 1999.
% \bibitem{polypi}     Robin Milner. \textit{The Polyadic $\pi$-Calculus: A Tutorial.} 1993.

\subsection*{Homotopy Type Systems}
\bibitem{streicher0} T.Streicher \textit{A groupoid model refutes uniqueness of identity proofs} 1994
\bibitem{streicher}  T.Streicher \textit{The Groupoid Interpretation of Type Theory} 1996
\bibitem{jacobs2}    B.Jacobs \textit{Categorical Logic and Type Theory} 1999
\bibitem{awodey}     S.Awodey \textit{Homotopy Type Theory and Univalent Foundations} 2013
\bibitem{huber}      S.Huber \textit{A Cubical Type Theory} 2015
\bibitem{joyal}      A.Joyal \textit{What is an elementary higher topos} 2014
\bibitem{mortberg}   A.Mortberg \textit{Cubical Type Theory: a constructive univalence axiom} 2017

\end{thebibliography}
\newpage

\end{document}
